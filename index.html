<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starship Arena (Clean Audio)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@700&display=swap');
        body { background-color: #0d1117; font-family: 'Chakra Petch', sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; overflow: hidden; }
        #game-container { 
            position: relative; 
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5), 0 0 50px rgba(0, 255, 255, 0.2); 
            border: 4px solid #00ffff; 
            border-radius: 12px; 
            background-color: #161b22; 
            width: 95vmin; 
            height: 95vmin;
        }
        canvas { display: block; touch-action: none; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(5px); border-radius: 8px; z-index: 10; pointer-events: none; }
        .game-over-visible { pointer-events: auto !important; }
        .game-button { transition: all 0.2s ease-in-out; box-shadow: 0 0 15px #00ffff; background: linear-gradient(145deg, #00bfff, #00ffff); color: #0d1117; text-transform: uppercase; letter-spacing: 2px; font-size: 1.25rem; padding: 0.75rem 2rem; font-weight: 700; }
        .game-button:hover { transform: scale(1.05); box-shadow: 0 0 25px #00ffff, 0 0 50px #00ffff; }
        #shopContainer { background-color: #161b22; border: 2px solid #39ff14; border-radius: 10px; max-width: 95%; width: 700px; max-height: 90%; display: grid; grid-template-rows: auto 1fr auto; gap: 1.5rem; padding: 2rem; }
        #shopContent { display: grid; grid-template-rows: auto 1fr; gap: 1.5rem; overflow-y: auto; max-height: 500px; padding-right: 10px; }
        #upgradeList { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; padding: 0.5rem 0; }
        #shipList { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; padding: 0.5rem; }
        .upgrade-card { background-color: #1f2733; border: 2px solid #ff4500; border-radius: 10px; padding: 1.5rem; display: flex; flex-direction: column; align-items: center; text-align: center; transition: all 0.3s; box-shadow: 0 0 20px rgba(255, 69, 0, 0.5); }
        .upgrade-card:hover { transform: scale(1.03); border-color: #ff8800; }
        .ship-card { background-color: #1f2733; border: 1px solid #334d60; border-radius: 10px; padding: 1rem; display: flex; flex-direction: column; align-items: center; transition: all 0.3s; }
        .ship-card.equipped { border: 3px solid #39ff14; transform: scale(1.05); box-shadow: 0 0 30px #39ff14; }
        .ship-card:not(.equipped):hover { transform: translateY(-8px); border-color: #00ffff; }
        .ship-card[data-glow] { border: 2px solid var(--glow-color); box-shadow: 0 0 10px var(--glow-color); }
        .ship-card.equipped[data-glow] { box-shadow: 0 0 30px var(--glow-color); }
        .game-info { position: absolute; top: 4px; left: 4px; right: 4px; display: flex; gap: 20px; flex-wrap: wrap; align-items: center; pointer-events: none; }
        .game-info > div { font-size: 1.2rem; font-weight: bold; padding: 6px 10px; border-radius: 8px; background: rgba(0, 0, 0, 0.6); pointer-events: auto; }
        
        @keyframes pulse-green {
            0%, 100% { text-shadow: 0 0 5px #39ff14; transform: scale(1); }
            50% { text-shadow: 0 0 20px #39ff14; transform: scale(1.1); }
        }
        .afford-alert {
            color: #39ff14;
            border: 1px solid #39ff14 !important;
            animation: pulse-green 1.5s infinite;
            display: none; 
        }
        .afford-visible { display: block !important; }
    </style>
</head>
<body>
    <div id="game-container" class="mx-auto">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
        <div class="game-info">
            <div id="livesDisplay" class="text-red-400">LIVES: 3</div>
            <div id="waveDisplay" class="text-purple-400">WAVE: 1</div>
            <div id="scoreDisplay" class="text-cyan-400">TIME: 0.00s</div>
            <div id="coinDisplay" class="text-yellow-400">COINS: 0</div>
            <div id="affordDisplay" class="afford-alert">NEXT SHIP AFFORDABLE!</div>
        </div>
        
        <div id="overlay">
            <div id="standardOverlay" class="flex flex-col justify-center items-center">
                <h1 id="overlayTitle" class="text-6xl mb-4 font-extrabold tracking-widest text-cyan-400"></h1>
                <p id="overlayMessage" class="text-4xl text-white mb-4 text-center"></p>
                <p id="totalCoinsMessage" class="text-3xl text-yellow-400 mb-8 text-center"></p>
                <button id="actionButton" class="game-button rounded-full"></button>
                <button id="shopButton" class="game-button rounded-full mt-4 bg-purple-600" style="box-shadow: 0 0 15px #ee82ee;">VISIT THE SHIPYARDS</button>
                <p class="text-sm text-gray-400 mt-6">(WASD / Arrows / Tap to move &amp; shoot)</p>
            </div>
            <div id="shopContainer" class="hidden w-full h-full p-4">
                <h2 class="text-4xl font-extrabold text-white mb-4 text-center pb-2 text-cyan-300">SHIP MARKETPLACE (60 DESIGNS)</h2>
                <div id="shopContent">
                    <h3 class="text-3xl font-extrabold text-orange-400 mb-2 border-b border-orange-700 pb-2">WEAPON SLOTS UPGRADES</h3>
                    <div id="upgradeList" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
                    <h3 class="text-3xl font-extrabold text-cyan-400 mt-4 mb-2 border-b border-cyan-700 pb-2">SHIP COLLECTION</h3>
                    <div id="shipList" class="grid"></div>
                </div>
                <div class="mt-4 flex flex-col sm:flex-row justify-between items-center border-t pt-4 border-cyan-500">
                    <p class="text-2xl text-yellow-400 font-bold mb-4 sm:mb-0">Balance: <span id="shopCoinBalance">0</span> COINS</p>
                    <button id="backButton" class="game-button rounded-full px-4 py-2" style="font-size: 1rem;">RETURN TO ARENA</button>
                </div>
            </div>
            <div id="cheatConsole" class="absolute bottom-4 left-4 right-4 hidden z-20">
                <input type="text" id="consoleInput" placeholder="Enter coin amount and press ENTER or '/' to close..." 
                       class="w-full bg-black/80 text-white p-3 border-2 border-green-500 font-mono text-xl focus:outline-none rounded-lg shadow-lg shadow-green-500/50">
            </div>
        </div>
    </div>

    <script>
        let coins = 0, sessionCoins = 0, equippedShipId = 'vanguard', ownedShipIds = ['vanguard'];
        let weaponSlots = 1; 
        let nextShipPrice = Infinity; 

        // --- WAVE SYSTEM VARIABLES ---
        let currentWave = 1;
        let killsInCurrentWave = 0;
        const KILLS_TO_ADVANCE_WAVE = 6;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const livesDisplay = document.getElementById('livesDisplay');
        const waveDisplay = document.getElementById('waveDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const coinDisplay = document.getElementById('coinDisplay');
        const affordDisplay = document.getElementById('affordDisplay');
        const totalCoinsMessage = document.getElementById('totalCoinsMessage');
        const overlay = document.getElementById('overlay');
        const standardOverlay = document.getElementById('standardOverlay');
        const shopContainer = document.getElementById('shopContainer');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayMessage = document.getElementById('overlayMessage');
        const actionButton = document.getElementById('actionButton');
        const shopButton = document.getElementById('shopButton');
        const backButton = document.getElementById('backButton');
        const shipList = document.getElementById('shipList');
        const upgradeList = document.getElementById('upgradeList');
        const shopCoinBalance = document.getElementById('shopCoinBalance');
        const cheatConsole = document.getElementById('cheatConsole');
        const consoleInput = document.getElementById('consoleInput');
        let isConsoleOpen = false;

        // --- GAME CONSTANTS ---
        const INITIAL_PLAYER_LIVES = 3;
        const PLAYER_SIZE = 25;
        const ENEMY_RADIUS = 30;
        const ROTATION_SPEED = 0.15;
        const MAX_ROTATION = Math.PI / 8;
        const SPREAD_ANGLE_RADIANS = 0.05; 
        const PLAYER_INVULNERABILITY_TIME = 2000; 
        const DAMAGE_FLASH_TIME = 100; // Time in ms for the red flash

        // --- GAME STATE ---
        let gameRunning = false;
        let animationFrameId = null;
        let player = { x: 0, y: 0, dx: 0, dy: 0, speed: 5, rotation: 0, particles: [], isInvulnerable: false, invulnTimer: 0 };
        let playerLives = INITIAL_PLAYER_LIVES;
        let enemies = [], projectiles = [], enemyProjectiles = [];
        let score = 0, lastTime = 0, spawnTimer = 0; 
        let keys = {};
        let screenFlashTimer = 0; // NEW: Timer for the red screen flash

        // --- NEW SIMPLE AUDIO SYSTEM ---
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'shoot') {
                // High pitch rapid decay (pew)
                osc.type = 'square';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'hit') {
                // Low pitch noise-like (boom)
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }
        }

        // --- SHIP DATA GENERATION (PRICES INCREASED) ---
        const RARITIES = {
            'vanguard': { multiplier: 1, color: '#40e0d0', glow: '#00ffff', basePrice: 0 },
            'Uncommon': { multiplier: 2, color: '#8b0000', glow: '#ff0000', basePrice: 150 },
            'Rare': { multiplier: 3, color: '#9400d3', glow: '#ee82ee', basePrice: 750 },
            'Epic': { multiplier: 4, color: '#daa520', glow: '#ffff00', basePrice: 2000 },
            'Legendary': { multiplier: 5, color: '#ffffff', glow: '#00bfff', basePrice: 5000 },
            'Mythic': { multiplier: 6, color: '#39ff14', glow: '#39ff14', basePrice: 12000 },
            'Cosmic': { multiplier: 8, color: '#0a001f', glow: '#ff00ff', basePrice: 30000 },
            'Eternal': { multiplier: 10, color: '#ff8800', glow: '#ff8800', basePrice: 75000 },
            'Apocalypse': { multiplier: 12, color: '#1a0033', glow: '#8a2be2', basePrice: 150000 },
            'Galactic': { multiplier: 15, color: '#ff0066', glow: '#ff0066', basePrice: 300000 },
            'Divine': { multiplier: 20, color: '#ff1a1a', glow: '#ff0066', basePrice: 1000000 }
        };

        const SHAPE_TYPES = ['ARROW', 'DELTA', 'CRUCIFORM', 'BOX', 'WING', 'STAR', 'U-SHAPE', 'SPHERE'];
        const SHIP_NAMES = ["Vanguard", "Viper", "Ghost", "Titan", "Quantum", "Nebula", "Voidreaper", "Chrono", "Oblivion", "Star Destroyer", "Phoenix", "Hammerhead", "Raptor", "Aegis", "Vortex", "Saber", "Maelstrom", "Hydra", "Sentinel", "Revenant", "Stalker", "Infiltrator", "Goliath", "Colossus", "Comet", "Drift", "Specter", "Astral", "Aurora", "Black Mamba", "Cyclone", "Dreadnought", "Eradicator", "Falcon", "Juggernaut", "Krait", "Leviathan", "Mantis", "Nova", "Onyx", "Prowler", "Quasar", "Rogue", "Scorpion", "Serpent", "Shadow", "Stingray", "Tempest", "Vigilante", "Warden", "Zephyr", "Apex", "Blazer", "Corsair", "Echo", "Harbinger", "Oracle", "Phantom", "Rift", "Viper-X"];

        function generateShipData() {
            let ships = [];
            const rarityKeys = Object.keys(RARITIES);
            
            for (let i = 0; i < 10; i++) {
                const rarityKey = i === 0 ? 'vanguard' : rarityKeys[Math.floor(i / 2) + 1];
                const rarity = RARITIES[rarityKey];
                ships.push({
                    id: SHIP_NAMES[i].toLowerCase().replace(' ', '-'),
                    name: SHIP_NAMES[i],
                    rarity: rarityKey === 'vanguard' ? 'Standard' : rarityKey,
                    multiplier: rarity.multiplier,
                    price: rarity.basePrice,
                    damage: Math.max(1, Math.floor(rarity.multiplier * 5 * (i === 0 ? 0.2 : 1))),
                    mainColor: rarity.color,
                    accentColor: rarity.color,
                    glowColor: rarity.glow,
                    engineColor: i === 0 ? '#ff6600' : rarity.glow,
                    shape: SHAPE_TYPES[i % 4],
                    wingCount: Math.min(i + 1, 4),
                    engineCount: Math.min(i + 1, 5),
                    sizeFactor: 1 + i * 0.05,
                    particleType: i % 4,
                });
            }

            for (let i = 10; i < 60; i++) {
                const rarityKey = rarityKeys[Math.floor((i - 10) / 5) + 2] || rarityKeys[rarityKeys.length - 1];
                const rarity = RARITIES[rarityKey];
                const randColor = () => '#' + (Math.random() * 0xFFFFFF << 0).toString(16).padStart(6, '0');

                ships.push({
                    id: SHIP_NAMES[i].toLowerCase().replace(' ', '-') || `ship-${i}`,
                    name: SHIP_NAMES[i] || `X-Class Interceptor ${i}`,
                    rarity: rarityKey,
                    multiplier: rarity.multiplier + Math.floor(Math.random() * 5),
                    price: rarity.basePrice * (2 + (i - 10) * 0.5),
                    damage: Math.max(5, Math.floor((rarity.multiplier + 5) * 10 * (1 + (i - 10) * 0.1))),
                    mainColor: randColor(),
                    accentColor: randColor(),
                    glowColor: rarity.glow,
                    engineColor: randColor(),
                    shape: SHAPE_TYPES[Math.floor(Math.random() * SHAPE_TYPES.length)],
                    wingCount: Math.floor(Math.random() * 4) + 1,
                    engineCount: Math.floor(Math.random() * 5) + 1,
                    sizeFactor: 1.5 + Math.random() * 0.5,
                    particleType: Math.floor(Math.random() * 4),
                });
            }
            return ships;
        }

        const SHIP_DATA = generateShipData();

        const MAX_WEAPON_SLOTS = 10;
        const UPGRADE_DATA = [
            { id: 'slot_2', name: 'Dual Cannon Slot', cost: 2500, targetSlots: 2, color: '#ff4500' },
            { id: 'slot_3', name: 'Triple Cannon Slot', cost: 7500, targetSlots: 3, color: '#ff8800' },
            { id: 'slot_4', name: 'Quad Cannon Slot', cost: 20000, targetSlots: 4, color: '#ffff00' },
            { id: 'slot_5', name: 'Penta Cannon Slot', cost: 50000, targetSlots: 5, color: '#39ff14' },
            { id: 'slot_6', name: 'Hexa Cannon Slot', cost: 100000, targetSlots: 6, color: '#00ff7f' },
            { id: 'slot_7', name: 'Hepta Cannon Slot', cost: 200000, targetSlots: 7, color: '#00bfff' },
            { id: 'slot_8', name: 'Octa Cannon Slot', cost: 400000, targetSlots: 8, color: '#9932cc' },
            { id: 'slot_9', name: 'Nona Cannon Slot', cost: 750000, targetSlots: 9, color: '#ff00ff' },
            { id: 'slot_10', name: 'Deca Cannon Slot (MAX)', cost: 1500000, targetSlots: 10, color: '#ff0066' },
        ];

        // --- UI & SHOP FUNCTIONS ---

        function updateNextShipPrice() {
            const unownedShips = SHIP_DATA.filter(s => !ownedShipIds.includes(s.id));
            if (unownedShips.length > 0) {
                unownedShips.sort((a, b) => a.price - b.price);
                nextShipPrice = unownedShips[0].price;
            } else {
                nextShipPrice = Infinity; 
            }
        }

        function updateCoinDisplay(){
            const currentTotal = coins + sessionCoins;
            coinDisplay.textContent = `COINS: ${currentTotal}`;
            livesDisplay.textContent = `LIVES: ${playerLives}`;
            waveDisplay.textContent = `WAVE: ${currentWave}`;
            
            if (currentTotal >= nextShipPrice && nextShipPrice !== Infinity) {
                affordDisplay.classList.add('afford-visible');
                const ship = SHIP_DATA.find(s => s.price === nextShipPrice && !ownedShipIds.includes(s.id));
                if(ship) affordDisplay.textContent = `AFFORDABLE: ${ship.name}`;
            } else {
                affordDisplay.classList.remove('afford-visible');
            }

            if(shopCoinBalance) shopCoinBalance.textContent = coins.toLocaleString();
        }

        function showShop(){
            standardOverlay.style.display='none';
            shopContainer.style.display='grid';
            overlay.style.display='flex';
            overlay.classList.add('game-over-visible');
            renderShop();
            updateCoinDisplay();
        }
        function renderUpgrades(){
            upgradeList.innerHTML = '';
            const upgradeData = UPGRADE_DATA.find(u => u.targetSlots === weaponSlots + 1);
            
            let cardHtml = '';
            
            if (weaponSlots >= MAX_WEAPON_SLOTS) {
                cardHtml = `<div class="upgrade-card bg-green-900/30 border-green-400">
                    <h3 class="text-2xl font-bold text-green-400 mb-2">MAX WEAPON SLOTS ACHIEVED</h3>
                    <p class="text-white text-lg mb-4">You currently fire <span class="text-cyan-400">${weaponSlots}</span> simultaneous bullets.</p>
                    <button class="px-4 py-2 text-sm rounded-full font-bold opacity-70 cursor-default bg-green-600 text-gray-900" disabled>MAXED OUT</button>
                </div>`;
            } else if (upgradeData) {
                const isAffordable = coins >= upgradeData.cost;
                const btnCls = isAffordable ? 'bg-yellow-500 hover:bg-yellow-400 text-gray-900 shadow-lg shadow-yellow-700/50' : 'bg-gray-500 text-gray-300 cursor-not-allowed';
                const action = isAffordable ? `attemptUpgrade('${upgradeData.id}',${upgradeData.cost},${upgradeData.targetSlots})` : '';
                
                cardHtml = `<div class="upgrade-card" style="border-color:${upgradeData.color}; box-shadow:0 0 20px ${upgradeData.color}50;">
                    <h3 class="text-3xl font-bold text-orange-400 mb-2">${upgradeData.name}</h3>
                    <p class="text-white text-lg mb-4">Increases shot count from ${weaponSlots} to <span class="text-cyan-400">${upgradeData.targetSlots}</span>.</p>
                    <p class="text-yellow-400 text-xl font-bold mb-4">${upgradeData.cost.toLocaleString()} COINS</p>
                    <button onclick="${action}" class="px-4 py-2 text-md rounded-full font-bold transition-all ${btnCls}" ${!isAffordable ? 'disabled' : ''}>
                        ${isAffordable ? 'BUY UPGRADE' : 'TOO EXPENSIVE'}
                    </button>
                    <p id="msg-upgrade" class="text-xs text-red-400 mt-2 h-4"></p>
                </div>`;
            }
            upgradeList.innerHTML = cardHtml;
        }

        function attemptUpgrade(id, price, newSlots){
            if(coins>=price){
                coins-=price; weaponSlots = newSlots;
                const msg=document.getElementById(`msg-upgrade`);
                if(msg){ msg.textContent=`${UPGRADE_DATA.find(u=>u.id===id).name} Purchased!`; msg.className='text-xs text-green-400 mt-2 h-4'; setTimeout(()=>msg.textContent='',2000); }
            }else{
                const msg=document.getElementById(`msg-upgrade`);
                if(msg){ msg.textContent='Not enough coins!'; msg.className='text-xs text-red-400 mt-2 h-4'; setTimeout(()=>msg.textContent='',2000); }
            }
            renderShop(); updateCoinDisplay();
        }

        function renderShop(){
            renderUpgrades();
            shipList.innerHTML='';
            SHIP_DATA.forEach(ship=>{
                const owned = ownedShipIds.includes(ship.id);
                const equipped = equippedShipId===ship.id;
                let btnTxt='EQUIP', btnCls='px-3 py-1 text-sm rounded-full font-bold transition-all', action=`equipShip('${ship.id}')`;
                
                if(!owned){
                    btnTxt=`BUY - ${ship.price.toLocaleString()} COINS`;
                    btnCls+=' bg-yellow-500 hover:bg-yellow-400 text-gray-900 shadow-lg shadow-yellow-700/50';
                    action=`attemptPurchase('${ship.id}',${ship.price})`;
                }else if(equipped){
                    btnTxt='EQUIPPED';
                    btnCls+=' bg-green-500 opacity-80 cursor-default text-gray-900 shadow-lg shadow-green-700/50';
                    action='';
                }else{
                    btnCls+=' bg-cyan-500 hover:bg-cyan-400 text-gray-900 shadow-lg shadow-cyan-700/50';
                }
                const rarityClr = ship.rarity.includes('vanguard')?'text-gray-400':ship.rarity==='Uncommon'?'text-green-400':ship.rarity==='Rare'?'text-blue-400':ship.rarity==='Epic'?'text-purple-400':ship.rarity==='Legendary'?'text-yellow-400':ship.rarity==='Mythic'?'text-pink-400':ship.rarity==='Cosmic'?'text-fuchsia-400':ship.rarity==='Eternal'?'text-orange-400':ship.rarity==='Apocalypse'?'text-purple-600':ship.rarity==='Galactic'?'text-red-400':ship.rarity==='Divine'?'text-red-600':'text-gray-400';
                
                const card=document.createElement('div');
                card.className=`ship-card ${equipped?'equipped':''}`;
                card.style.setProperty('--glow-color', ship.glowColor);
                card.dataset.glow = ship.glowColor;

                const shipSvg = `
                    <svg class="w-12 h-12" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="g${ship.id}" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:${ship.mainColor};stop-opacity:1" />
                                <stop offset="100%" style="stop-color:${ship.accentColor};stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <path d="M50,10 L80,90 L50,80 L20,90 Z" fill="url(#g${ship.id})" stroke="${ship.glowColor}" stroke-width="3" />
                        <circle cx="50" cy="50" r="10" fill="${ship.engineColor}" style="filter: drop-shadow(0 0 5px ${ship.glowColor});"/>
                    </svg>
                `;

                card.innerHTML=`
                    <h3 class="text-2xl font-bold ${rarityClr} mb-1">${ship.name}</h3>
                    <p class="text-sm ${rarityClr} italic mb-2">(${ship.rarity})</p>
                    <div class="w-20 h-20 flex items-center justify-center mb-4 border-2 border-white/20"
                         style="background-color:rgba(255,255,255,0.05);box-shadow:0 0 10px ${ship.glowColor}50;border-radius:10px;">
                        ${shipSvg}
                    </div>
                    <p class="text-white text-lg font-mono mb-1">Multiplier: <span class="text-cyan-400">${ship.multiplier}x</span></p>
                    <p class="text-white text-lg font-mono mb-4">Damage: <span class="text-red-400">${ship.damage}</span></p>
                    <button onclick="${action}" class="${btnCls}" ${equipped?'disabled':''}>${btnTxt}</button>
                    <p id="msg-${ship.id}" class="text-xs text-red-400 mt-2 h-4"></p>
                `;
                shipList.appendChild(card);
            });
        }
        
        function attemptPurchase(id,price){
            if(coins>=price){
                coins-=price; ownedShipIds.push(id); equipShip(id);
                updateNextShipPrice(); 
                const msg=document.getElementById(`msg-${id}`);
                if(msg){ msg.textContent='Purchased & Equipped!'; msg.className='text-xs text-green-400 mt-2 h-4'; setTimeout(()=>msg.textContent='',2000); }
            }else{
                const msg=document.getElementById(`msg-${id}`);
                if(msg){ msg.textContent='Not enough coins!'; msg.className='text-xs text-red-400 mt-2 h-4'; setTimeout(()=>msg.textContent='',2000); }
            }
            renderShop(); updateCoinDisplay();
        }
        function equipShip(id){
            if(ownedShipIds.includes(id)){
                equippedShipId=id; renderShop();
                const cur=SHIP_DATA.find(s=>s.id===equippedShipId);
                document.documentElement.style.setProperty('--player-color', cur.mainColor);
                document.documentElement.style.setProperty('--player-glow', cur.glowColor);
                const msg=document.getElementById(`msg-${id}`);
                if(msg){ msg.textContent='Equipped!'; msg.className='text-xs text-green-400 mt-2 h-4'; setTimeout(()=>msg.textContent='',2000); }
            }
        }

        // --- GAME FLOW & SETUP ---

        function resizeCanvas(){
            const container=document.getElementById('game-container');
            const size=Math.min(container.offsetWidth,container.offsetHeight);
            canvas.width=size; canvas.height=size;
        }

        async function startGame(){
            initAudio();
            resizeCanvas();
            player.x=canvas.width/2; player.y=canvas.height*0.85;
            player.dx=player.dy=player.rotation=0; player.particles=[];
            player.isInvulnerable = false; player.invulnTimer = 0;
            enemies=[]; projectiles=[]; enemyProjectiles=[]; 
            playerLives = INITIAL_PLAYER_LIVES; 
            score=0; sessionCoins=0;
            lastTime=performance.now(); lastCoinUpdateTime=lastTime; lastHitSoundTime=0;
            spawnTimer=0; keys={};
            screenFlashTimer = 0; // Reset flash timer
            
            currentWave = 1;
            killsInCurrentWave = 0;
            
            updateNextShipPrice();

            const cur=SHIP_DATA.find(s=>s.id===equippedShipId);
            document.documentElement.style.setProperty('--player-color', cur.mainColor);
            document.documentElement.style.setProperty('--player-glow', cur.glowColor);

            overlay.classList.remove('game-over-visible'); overlay.style.display='none';
            gameRunning=true;
            updateCoinDisplay(); 
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function initStartScreen(){
            toggleConsole(false);
            updateNextShipPrice();

            resizeCanvas(); draw(); updateCoinDisplay();
            shopContainer.style.display='none'; standardOverlay.style.display='flex';
            overlayTitle.textContent='STARSHIP ARENA';
            overlayTitle.className='text-6xl mb-4 font-extrabold tracking-widest text-cyan-400';
            const cur=SHIP_DATA.find(s=>s.id===equippedShipId);
            overlayMessage.textContent=`Equipped: ${cur.name} (${cur.multiplier}x Multiplier, ${cur.damage} Damage). Weapon Slots: ${weaponSlots}.`; 
            totalCoinsMessage.textContent=''; actionButton.textContent='START ARENA';
            overlay.style.display='flex'; overlay.classList.add('game-over-visible');
        }

        function loseLife() {
            if (player.isInvulnerable || !gameRunning) return;

            playerLives--;
            
            // NEW: Start the screen flash timer
            screenFlashTimer = DAMAGE_FLASH_TIME; 
            
            if (playerLives <= 0) {
                playerLives = 0;
                gameOver();
                return; 
            }

            player.isInvulnerable = true;
            player.invulnTimer = PLAYER_INVULNERABILITY_TIME;
            updateCoinDisplay();
            projectiles = [];
            enemyProjectiles = [];
        }

        function gameOver(){
            if (!gameRunning) return; 
            gameRunning = false;
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            coins += sessionCoins;
            shopContainer.style.display='none'; standardOverlay.style.display='flex';
            overlayTitle.textContent='DEFEAT';
            overlayTitle.className='text-6xl mb-4 font-extrabold tracking-widest text-red-500 animate-pulse';
            const ship=SHIP_DATA.find(s=>s.id===equippedShipId);
            overlayMessage.textContent=`Survived ${score.toFixed(2)}s | Waves Defeated: ${currentWave-1}`;
            totalCoinsMessage.textContent=`TOTAL BALANCE: ${coins.toLocaleString()} COINS`;
            actionButton.textContent='RESTART ARENA';
            overlay.style.display='flex'; overlay.classList.add('game-over-visible');
            updateCoinDisplay();
        }

        // --- ENEMY LOGIC ---

        function spawnEnemy(){
            if (!gameRunning) return;
            const waveMultiplier = 1 + (currentWave * 0.20); 
            const baseSize = ENEMY_RADIUS + Math.random()*15;
            const size = baseSize;
            const health = Math.max(2, Math.floor((size * 0.5) * waveMultiplier));
            
            const enemySpeed = 1.0 + Math.min(score/60, 3.0);
            const damage = Math.max(1, Math.floor(enemySpeed * 2) + (currentWave * 2)); 

            const visuals = [
                { c: '#800080', g: '#ff00ff' }, 
                { c: '#8b0000', g: '#ff0000' }, 
                { c: '#006400', g: '#39ff14' }, 
                { c: '#00008b', g: '#00bfff' }, 
                { c: '#b8860b', g: '#ffd700' }, 
                { c: '#000000', g: '#ffffff' }  
            ];
            const style = visuals[(currentWave - 1) % visuals.length];

            enemies.push({
                x:Math.random()*(canvas.width-size*2)+size, 
                y:-size, 
                radius: size, 
                speed: enemySpeed, 
                health, 
                maxHealth: health,
                shotCooldown: 2000 + Math.random() * 2000 - Math.min(score*10, 1500),
                shootTimer: 0,
                color: style.c, 
                glow: style.g, 
                damage: damage,
            });
        }

        function spawnEnemyProjectile(enemy){
            if(!gameRunning || isConsoleOpen) return;
            
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.hypot(dx, dy);
            const vx = dx / dist;
            const vy = dy / dist;

            enemyProjectiles.push({
                x: enemy.x, 
                y: enemy.y + enemy.radius,
                radius: 4,
                speed: 8,
                damage: enemy.damage,
                color: enemy.glow,
                vx: vx, 
                vy: vy, 
            });
        }
        
        // --- PROJECILE LOGIC ---

        function shootProjectile(){
            if(!gameRunning || isConsoleOpen) return;
            const ship=SHIP_DATA.find(s=>s.id===equippedShipId);
            if(!ship) return;
            
            // Play sound
            playSound('shoot');

            const damage = ship.damage;
            const color = ship.glowColor;
            const speed = 15;
            const radius = 4;

            const cannonPositionSpread = 15; 

            for (let i = 0; i < weaponSlots; i++) {
                const positionOffset = (i - (weaponSlots - 1) / 2) * cannonPositionSpread;
                const angleOffset = (i - (weaponSlots - 1) / 2) * SPREAD_ANGLE_RADIANS;
                
                const vx = Math.sin(angleOffset);      
                const vy = -Math.cos(angleOffset);     

                projectiles.push({
                    x: player.x + positionOffset, 
                    y: player.y - PLAYER_SIZE,
                    radius: radius,
                    speed: speed,
                    damage: damage,
                    color: color,
                    vx: vx, 
                    vy: vy,
                });
            }
        }

        // --- UPDATE LOOP COMPONENTS ---

        function updateParticles(delta){
            const ship=SHIP_DATA.find(s=>s.id===equippedShipId);
            if(!ship || ship.particleType===0){ player.particles=[]; return; }
            const halfSize = PLAYER_SIZE * ship.sizeFactor * 0.5;

            const enginePositions = ship.engineCount === 1 ? [0] : Array.from({length: ship.engineCount}, (_, i) => (i - (ship.engineCount - 1) / 2) * (halfSize * 0.6 / (ship.engineCount - 1 || 1)));

            if(Math.random()<0.8){
                enginePositions.forEach(offsetX => {
                    const a = player.rotation;
                    const len = halfSize * 1.5;
                    const px = offsetX * Math.cos(a) + len * Math.sin(a); 
                    const py = -offsetX * Math.sin(a) + len * Math.cos(a);

                    player.particles.push({
                        x: player.x - px + (Math.random()-0.5)*4,
                        y: player.y + py + (Math.random()-0.5)*4,
                        vx: -(Math.sin(a)*0.2 + (Math.random()-0.5)*0.2),
                        vy: (Math.cos(a)*0.2 + Math.random()*2),
                        life: 100,
                        size: ship.particleType===3 ? 3 : 1.5,
                        color: ship.engineColor
                    });
                });
            }

            for(let i=player.particles.length-1;i>=0;i--){
                const p=player.particles[i];
                p.x+=p.vx*delta/16.67; p.y+=p.vy*delta/16.67;
                p.life--; p.vy*=0.98;
                if(p.life<=0) player.particles.splice(i,1);
            }
        }

        function updateGameObjects(delta){
            if (!gameRunning) return; 

            const deltaFactor = delta/16.67;

            if (player.isInvulnerable) {
                player.invulnTimer -= delta;
                if (player.invulnTimer <= 0) {
                    player.isInvulnerable = false;
                }
            }
            
            // NEW: Decrement the screen flash timer
            if (screenFlashTimer > 0) {
                screenFlashTimer -= delta;
                if (screenFlashTimer < 0) screenFlashTimer = 0;
            }

            spawnTimer-=delta;
            const maxEnemies = Math.min(20, 1 + currentWave);
            
            if(spawnTimer<=0 && enemies.length < maxEnemies){ 
                spawnEnemy(); 
                spawnTimer=1000; 
            }

            for(let i=enemies.length-1;i>=0;i--){
                const e=enemies[i];
                e.y+=e.speed*deltaFactor;
                if(e.y-e.radius>canvas.height){ enemies.splice(i,1); continue; }
                
                e.shootTimer -= delta;
                if (e.shootTimer <= 0) {
                    spawnEnemyProjectile(e);
                    e.shootTimer = e.shotCooldown;
                }

                // --- CRASH FIX 1: Enemy collision ---
                if(!player.isInvulnerable && checkCollision(player, e)){ 
                    loseLife();
                    return; // Return immediately to prevent array manipulation after reset in loseLife()
                }
            }

            for(let i=projectiles.length-1;i>=0;i--){
                const p=projectiles[i];
                p.x += p.vx * p.speed * deltaFactor; 
                p.y += p.vy * p.speed * deltaFactor;
                
                if(p.y+p.radius<0 || p.x+p.radius<0 || p.x-p.radius>canvas.width){ projectiles.splice(i,1); continue; }
                
                let hit=false;
                for(let j=enemies.length-1;j>=0;j--){
                    const e=enemies[j];
                    const d=Math.hypot(p.x-e.x,p.y-e.y);
                    if(d<(p.radius+e.radius)){
                        hit=true; e.health-=p.damage; 
                        
                        if(e.health<=0){
                            playSound('hit');
                            const reward = 20;
                            sessionCoins+=reward; 
                            enemies.splice(j,1);

                            killsInCurrentWave++;
                            if (killsInCurrentWave >= KILLS_TO_ADVANCE_WAVE) {
                                currentWave++;
                                killsInCurrentWave = 0;
                            }
                            updateCoinDisplay();
                        }
                        break;
                    }
                }
                if(hit) projectiles.splice(i,1);
            }

            for(let i=enemyProjectiles.length-1;i>=0;i--){
                const ep=enemyProjectiles[i];
                ep.x += ep.vx * ep.speed * deltaFactor; 
                ep.y += ep.vy * ep.speed * deltaFactor;

                if(ep.y+ep.radius<0 || ep.x+ep.radius<0 || ep.x-ep.radius>canvas.width || ep.y-ep.radius>canvas.height){ 
                    enemyProjectiles.splice(i,1); continue; 
                }

                // --- CRASH FIX 2: Enemy projectile collision ---
                if(!player.isInvulnerable && checkCollision(player, ep)){
                    loseLife();
                    return; // Return immediately to prevent array manipulation after reset in loseLife()
                }
            }
        }

        function update(now){
            if(!gameRunning || isConsoleOpen) return;
            const delta=now-lastTime; lastTime=now; const sec=delta/1000;
            score+=sec; scoreDisplay.textContent=`TIME: ${score.toFixed(2)}s`;
            const ship=SHIP_DATA.find(s=>s.id===equippedShipId);
            const mult=ship?ship.multiplier:1;

            let mx=0,my=0;
            if(keys['w']||keys['W']||keys['ArrowUp']) my=-1;
            else if(keys['s']||keys['S']||keys['ArrowDown']) my=1;
            if(keys['a']||keys['A']||keys['ArrowLeft']) mx=-1;
            else if(keys['d']||keys['D']||keys['ArrowRight']) mx=1;
            if(mx&&my){ const m=Math.sqrt(mx*mx+my*my); mx/=m; my/=m; }
            player.x+=mx*player.speed; player.y+=my*player.speed;

            const targetRot = mx<0?-MAX_ROTATION:mx>0?MAX_ROTATION:0;
            player.rotation += (targetRot-player.rotation)*ROTATION_SPEED;

            const half=PLAYER_SIZE/2;
            player.x=Math.max(half,Math.min(canvas.width-half,player.x));
            player.y=Math.max(half,Math.min(canvas.height-half,player.y));

            updateParticles(delta);
            updateGameObjects(delta);
        }

        // --- DRAWING COMPONENTS ---

        function checkCollision(p1,p2){
            if (!gameRunning) return false;
            const r1 = p1.radius || PLAYER_SIZE/2; 
            const r2 = p2.radius || PLAYER_SIZE/2; 
            return Math.hypot(p1.x-p2.x,p1.y-p2.y) < (r1 + r2);
        }

        function drawShip(ctx, ship, x, y, rotation, isPlayer = false, playerInvuln = false){
            const r = PLAYER_SIZE * ship.sizeFactor * 0.5; 
            const glow = ship.glowColor;
            const engine = ship.engineColor;
            const main = ship.mainColor;
            const accent = ship.accentColor;

            ctx.save();
            ctx.translate(x,y);
            ctx.rotate(rotation);

            if (isPlayer) {
                if(playerInvuln && Math.floor(player.invulnTimer / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.5; 
                }
                player.particles.forEach(p=>{
                    ctx.globalAlpha=p.life/100;
                    ctx.fillStyle=p.color;
                    ctx.beginPath();
                    ctx.arc(p.x-x,p.y-y,p.size*(p.life/100),0,Math.PI*2);
                    ctx.fill();
                });
                ctx.globalAlpha=1;
            }

            ctx.shadowColor=engine; ctx.shadowBlur=15;
            ctx.fillStyle=engine;
            const engineWidth = r * 0.3;
            const engineSeparation = r * 0.8;
            const engineLength = r * 0.8;
            
            const enginePositions = ship.engineCount === 1 ? [0] : Array.from({length: ship.engineCount}, (_, i) => (i - (ship.engineCount - 1) / 2) * (engineSeparation / (ship.engineCount - 1 || 1)));

            enginePositions.forEach(offsetX => {
                ctx.fillRect(offsetX - engineWidth/2, r, engineWidth, engineLength);
            });
            ctx.shadowBlur=0;

            ctx.shadowColor=glow; ctx.shadowBlur=20;
            ctx.fillStyle=main;
            
            ctx.beginPath();
            
            switch(ship.shape) {
                case 'DELTA': 
                    ctx.moveTo(0, -r*1.5);
                    ctx.lineTo(r*1.5, r);
                    ctx.lineTo(-r*1.5, r);
                    break;
                case 'ARROW': 
                    ctx.moveTo(0, -r*1.8);
                    ctx.lineTo(r*1.2, r*0.5);
                    ctx.lineTo(r*0.6, r);
                    ctx.lineTo(-r*0.6, r);
                    ctx.lineTo(-r*1.2, r*0.5);
                    break;
                case 'CRUCIFORM':
                    ctx.rect(-r*0.4, -r*1.2, r*0.8, r*2.4);
                    ctx.moveTo(-r*1.5, r*0.5);
                    ctx.lineTo(-r*0.4, r*0.1);
                    ctx.lineTo(-r*0.4, r*0.9);
                    ctx.moveTo(r*1.5, r*0.5);
                    ctx.lineTo(r*0.4, r*0.1);
                    ctx.lineTo(r*0.4, r*0.9);
                    break;
                case 'BOX':
                    ctx.rect(-r, -r*1.2, r*2, r*2.4);
                    break;
                case 'WING':
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r*2.5, r*0.5);
                    ctx.lineTo(r*1.5, r);
                    ctx.lineTo(-r*1.5, r);
                    ctx.lineTo(-r*2.5, r*0.5);
                    break;
                case 'STAR':
                    const numPoints = 5;
                    for (let i = 0; i < numPoints * 2; i++) {
                        const outer = i % 2 === 0;
                        const len = outer ? r * 2 : r * 0.8;
                        const angle = Math.PI/2 - i * Math.PI / numPoints;
                        ctx.lineTo(len * Math.cos(angle), -len * Math.sin(angle));
                    }
                    break;
                case 'U-SHAPE':
                    ctx.moveTo(-r*1.5, r);
                    ctx.lineTo(-r*1.5, -r);
                    ctx.lineTo(-r*0.5, -r);
                    ctx.lineTo(-r*0.5, r);
                    ctx.lineTo(r*0.5, r);
                    ctx.lineTo(r*0.5, -r);
                    ctx.lineTo(r*1.5, -r);
                    ctx.lineTo(r*1.5, r);
                    break;
                case 'SPHERE':
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    break;
                default:
                    ctx.rect(-r*0.8, -r*1.2, r*1.6, r*2.4);
            }
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur=0;

            ctx.fillStyle=accent;
            ctx.beginPath();
            ctx.rect(-r*0.3, -r*1.0, r*0.6, r*0.8);
            ctx.fill();

            ctx.restore();
        }

        function drawEnemy(enemy){
            const r = enemy.radius;
            const dmg=enemy.health/enemy.maxHealth;
            const pulse = (Math.sin(performance.now() / 150) * 0.1 + 1); 

            ctx.save();
            ctx.translate(enemy.x, enemy.y);

            ctx.fillStyle='#0d1117';
            ctx.fillRect(-r, -r-10, r*2, 6);
            ctx.fillStyle=dmg>0.5?'#39ff14':dmg>0.2?'#ffff00':'#ff0000';
            ctx.fillRect(-r, -r-10, r*2*dmg, 6);

            ctx.shadowColor=enemy.glow; ctx.shadowBlur=20;
            ctx.fillStyle=enemy.color;
            
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI*2);
            ctx.fill();
            
            ctx.fillStyle='#0d1117'; 
            ctx.beginPath();
            ctx.arc(0, 0, r*0.5, 0, Math.PI*2);
            ctx.fill();

            ctx.fillStyle=enemy.glow; 
            ctx.beginPath();
            ctx.rect(-r*0.1, r*0.5, r*0.2, r*0.4*pulse);
            ctx.fill();

            ctx.restore();
        }


        function draw(){
            if(!gameRunning) return;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle='#161b22'; ctx.fillRect(0,0,canvas.width,canvas.height);

            projectiles.forEach(p=>{
                ctx.fillStyle=p.color; ctx.shadowColor=p.color; ctx.shadowBlur=10;
                ctx.beginPath(); ctx.arc(p.x,p.y,p.radius,0,Math.PI*2); ctx.fill();
            }); 
            enemyProjectiles.forEach(ep=>{
                ctx.fillStyle=ep.color; ctx.shadowColor=ep.color; ctx.shadowBlur=10;
                ctx.beginPath(); ctx.arc(ep.x,ep.y,ep.radius,0,Math.PI*2); ctx.fill();
            });
            ctx.shadowBlur=0;

            enemies.forEach(e => drawEnemy(e));

            const currentShip = SHIP_DATA.find(s=>s.id===equippedShipId);
            drawShip(ctx, currentShip, player.x, player.y, player.rotation, true, player.isInvulnerable);
            
            // NEW: Draw red flash overlay
            if (screenFlashTimer > 0) {
                const maxAlpha = 0.5; // Max transparency
                // Fades out from 0.5 opacity over the flash time
                const alpha = maxAlpha * (screenFlashTimer / DAMAGE_FLASH_TIME); 
                
                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function gameLoop(t){
            if(!gameRunning || isConsoleOpen) return;
            update(t); 
            if(gameRunning) { 
                draw(); 
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // --- CONSOLE LOGIC ---

        function toggleConsole(open) {
            if (open !== undefined) { isConsoleOpen = open; } else { isConsoleOpen = !isConsoleOpen; }
            if (isConsoleOpen) {
                cheatConsole.style.display = 'block';
                consoleInput.value = coins.toLocaleString();
                consoleInput.focus();
                overlay.style.display = 'flex';
                overlay.classList.add('game-over-visible');
            } else {
                cheatConsole.style.display = 'none';
                consoleInput.blur();
                if (gameRunning && standardOverlay.style.display !== 'flex') {
                    overlay.style.display = 'none';
                    overlay.classList.remove('game-over-visible');
                }
            }
        }

        function processConsoleInput() {
            const value = parseInt(consoleInput.value.replace(/,/g, ''), 10); 
            if (!isNaN(value) && value >= 0) {
                coins = value;
                updateCoinDisplay();
            } else {
                consoleInput.value = "Invalid input.";
                consoleInput.classList.add('text-red-500');
                setTimeout(() => {
                    consoleInput.value = coins.toLocaleString();
                    consoleInput.classList.remove('text-red-500');
                }, 1500);
            }
            toggleConsole(false);
        }

        // --- EVENT LISTENERS ---
        
        document.addEventListener('keydown', e => {
            if (e.key === '/') { e.preventDefault(); toggleConsole(); return; }
            if (isConsoleOpen) {
                if (e.key === 'Enter') { e.preventDefault(); processConsoleInput(); }
                return;
            }
            if (!isConsoleOpen) {
                keys[e.key] = true;
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
                if (e.key === ' ' && gameRunning) shootProjectile();
            }
        });
        document.addEventListener('keyup', e => { if (!isConsoleOpen) { keys[e.key] = false; } });

        canvas.addEventListener('click', () => {
            if(gameRunning && !isConsoleOpen) { shootProjectile(); } else if (!isConsoleOpen) { showShop(); }
        });

        let touchStart={x:0,y:0},touchTimer=0,isMoving=false;
        canvas.addEventListener('touchstart',e=>{
            if (isConsoleOpen) return;
            e.preventDefault();
            const t=e.touches[0];
            touchStart.x=t.clientX; touchStart.y=t.clientY;
            touchTimer=Date.now(); isMoving=false;
            const rect=canvas.getBoundingClientRect();
            const tx=t.clientX-rect.left, ty=t.clientY-rect.top;
            const dx=tx-player.x, dy=ty-player.y;
            let mx=0,my=0;
            if(Math.abs(dx)>10) mx=dx>0?1:-1;
            if(Math.abs(dy)>10) my=dy>0?1:-1;
            keys['w']=my<0; keys['s']=my>0; keys['a']=mx<0; keys['d']=mx>0;
        },{passive:false});
        canvas.addEventListener('touchmove',e=>{
            if (isConsoleOpen) return;
            e.preventDefault(); isMoving=true;
            const t=e.touches[0];
            const dx=t.clientX-touchStart.x, dy=t.clientY-touchStart.y;
            const thr=15;
            keys['w']=dy<-thr; keys['s']=dy>thr; keys['a']=dx<-thr; keys['d']=dx>thr;
        },{passive:false});
        canvas.addEventListener('touchend',()=>{
            if (isConsoleOpen) return;
            keys['w']=keys['s']=keys['a']=keys['d']=false;
            const dur=Date.now()-touchTimer;
            if(dur<150 && !isMoving) {
                if(gameRunning) { shootProjectile(); } else { showShop(); }
            }
        });

        actionButton.addEventListener('click',startGame);
        shopButton.addEventListener('click',showShop);
        backButton.addEventListener('click',initStartScreen);
        window.addEventListener('resize',resizeCanvas);

        initStartScreen();
        
        window.attemptPurchase = attemptPurchase;
        window.equipShip = equipShip;
        window.attemptUpgrade = attemptUpgrade;
    </script>
</body>
</html>
